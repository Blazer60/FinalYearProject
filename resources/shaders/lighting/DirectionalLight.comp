#version 460 core

#include "../interfaces/DirectionalLightBlock.h"
#include "../classification/ClassificationBuffer.glsl"
#include "Brdf.glsl"

layout(binding = 0) uniform sampler2D depthBufferTexture;
layout(binding = 1) uniform sampler2DArray u_shadow_map_texture;

layout(binding = 1, rgba16f) uniform image2D lighting;

float sample_shadow_map(vec2 uv, float depth, float bias, int layer)
{
    const float shadow_depth = texture(u_shadow_map_texture, vec3(uv, layer)).r;
    return depth - bias > shadow_depth ? 1.f : 0.f;
}

float calculate_shadow_map(vec3 position, vec3 normal)
{
    const float depth = abs((camera.viewMatrix * vec4(position, 1.f)).z);
    int layer = light.cascadeCount;
    for (int i = 0; i < light.cascadeCount; ++i)
    {
        if (depth < light.cascadeDistances[i / 4][i % 4])
        {
            layer = i;
            break;
        }
    }

    const vec4 position_light_space = light.vpMatrices[layer] * vec4(position, 1.f);
    vec3 projection_coords = position_light_space.xyz / position_light_space.w;
    projection_coords = 0.5f * projection_coords + 0.5f;
    const float current_depth = projection_coords.z;
    const float bias = mix(light.bias.x, light.bias.y, max(dot(normal, -light.direction), 0.f));

    if (current_depth < 1.f)
    {
        vec2 texel_size = 1.f / textureSize(u_shadow_map_texture, 0).xy;
        float sum = 0.f;
        sum += sample_shadow_map(projection_coords.xy + (texel_size * vec2(-1.5f, -1.5f)), current_depth, bias, layer);
        sum += sample_shadow_map(projection_coords.xy + (texel_size * vec2( 1.5f, -1.5f)), current_depth, bias, layer);
        sum += sample_shadow_map(projection_coords.xy + (texel_size * vec2(-1.5f,  1.5f)), current_depth, bias, layer);
        sum += sample_shadow_map(projection_coords.xy + (texel_size * vec2( 1.5f,  1.5f)), current_depth, bias, layer);
        return 0.25f * sum;
    }
    return 0.f;
}


layout(local_size_x = TILE_THREAD_GROUP_SIZE, local_size_y = TILE_THREAD_GROUP_SIZE, local_size_z = 1) in;
void main()
{
    const uint tileIndex = gl_WorkGroupID.x;
    const uint tileBufferResult = tileBuffers[tileIndex][SHADER_INDEX];
    const uvec2 workGroupId = uvec2(tileBufferResult & 0x0000FFFFu, (tileBufferResult & 0xFFFF0000u) >> 16);

    const uvec2 pixelCoord = workGroupId * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy;
    const vec2 id = vec2(pixelCoord);

    const vec2 uv = (id - vec2(0.5f)) / textureSize(depthBufferTexture, 0);

    const float depth = texture(depthBufferTexture, uv).r;
    const vec3 position = positionFromDepth(uv, depth);

    GBuffer gBuffer = pullFromStorageGBuffer(ivec2(id));

    const vec3 l = normalize(light.direction);
    const float attenuation = 1.f;
    const float shadow_intensity = calculate_shadow_map(position, gBuffer.normal);
    const vec3 radiance = (1.f - shadow_intensity) * light.intensity * attenuation;

    vec3 colour = imageLoad(lighting, ivec2(id)).rgb;
    colour += camera.exposure * evaluateBxDF(gBuffer, position, l, radiance);
    imageStore(lighting, ivec2(id), vec4(colour, 1.f));
}
