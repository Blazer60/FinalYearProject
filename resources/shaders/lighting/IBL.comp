#version 460

#include "../geometry/GBuffer.glsl"
#include "../Camera.glsl"
#include "Brdf.glsl"
#include "../Maths.glsl"
#include "../interfaces/ThreadGroupSizes.h"

#if !defined(WHITE_FURNACE_TEST)
    #define WHITE_FURNACE_TEST 0
#endif
#if WHITE_FURNACE_TEST > 0
    #include "../Colour.glsl"
#endif

layout(binding = 0) uniform sampler2D depthBufferTexture;
layout(binding = 1) uniform sampler2D u_brdf_lut_texture;
layout(binding = 2) uniform sampler2D directionAlbedoF1Texture;
layout(binding = 3) uniform sampler2D directionAlbedoF1AverageTexture;
layout(binding = 4) uniform sampler2D missingSpecularLutTexture;

#if WHITE_FURNACE_TEST <= 0

layout(binding = 5) uniform samplerCube u_irradiance_texture;
layout(binding = 6) uniform samplerCube u_pre_filter_texture;

uniform float u_luminance_multiplier;

#endif

layout(binding = 1, rgba16f) uniform image2D lighting;

vec3 averageFresnel(vec3 f0)
{
    return (20.f / 21.f) * f0 + vec3(1.f / 21.f);
}

float averageRspecF1(float roughness)
{
    return texture(directionAlbedoF1AverageTexture, vec2(roughness, 0.5f)).r;
}

float rspecF1(float nDotS, float roughness)
{
    return texture(directionAlbedoF1Texture, vec2(nDotS, roughness)).r;
}

vec3 reconstructSpecularMissing(vec3 f0, float nDotV, float roughness)
{
    const vec3 f0Average = averageFresnel(f0);

    const float avgRspec = averageRspecF1(roughness);
    const float oneMinusAvgRspec = 1.f - avgRspec;

    const float thatSummationPartOnTheRight = texture(missingSpecularLutTexture, vec2(nDotV, roughness)).r;

    const vec3 denominator = (vec3(1.f) - f0Average * oneMinusAvgRspec);

    return f0Average * avgRspec / denominator * thatSummationPartOnTheRight;
}

layout(local_size_x = FULLSCREEN_THREAD_GROUP_SIZE, local_size_y = FULLSCREEN_THREAD_GROUP_SIZE, local_size_z = 1) in;
void main()
{
    const vec2 id = gl_GlobalInvocationID.xy;
    const vec2 dispatchSize = gl_NumWorkGroups.xy * gl_WorkGroupSize.xy;
    const vec2 uv = (id - vec2(0.5f)) / textureSize(depthBufferTexture, 0);
    const float depth = texture(depthBufferTexture, uv).r;
    const vec3 position = positionFromDepth(uv, depth);

    GBuffer gBuffer = pullFromStorageGBuffer(ivec2(id));

    const vec3 n = gBuffer.normal;
    const vec3 v = normalize(camera.position - position);
    const vec3 r = reflect(-v, n);

    const float vDotN = max(dot(v, n), 0.f);

#if WHITE_FURNACE_TEST > 0
    const vec3 fresnel = vec3(1.f);
#else
    const vec3 fresnel = fresnelSchlick(gBuffer.specular, vDotN);
#endif

    const vec2 lut = texture(u_brdf_lut_texture, vec2(vDotN, gBuffer.roughness)).rg;
    const vec3 specular = (fresnel * lut.x + lut.y);
    const vec3 specMissing = reconstructSpecularMissing(fresnel, vDotN, gBuffer.roughness);

    const vec3 diffuse = evaluateDiffuseBrdf(gBuffer, fresnel);

#if WHITE_FURNACE_TEST > 0
    const vec3 colour = linearToSRgb(specular + specMissing) - vec3(0.5f);
//    if (depth >= 1)
//        imageStore(lighting, ivec2(id), vec4(linearToSRgb(vec3(1.f)) - vec3(0.5f), 1.f));
//    else
        imageStore(lighting, ivec2(id), vec4(colour, 1.f));
#else

    const float maxReflectionLod = 4.f;
    const vec3 preFilterColour = textureLod(u_pre_filter_texture, r, gBuffer.roughness * maxReflectionLod).rgb;
    const vec3 irradiance = texture(u_irradiance_texture, n).rgb;

    const vec3 colour = imageLoad(lighting, ivec2(id)).rgb;
    const vec3 outColour = colour + camera.exposure * ((specular + specMissing) * preFilterColour + diffuse * irradiance) * u_luminance_multiplier;
    imageStore(lighting, ivec2(id), vec4(outColour, 1.f));
#endif
}
