#version 460

#if !defined(WHITE_FURNACE_TEST)
    #define WHITE_FURNACE_TEST 0
#endif

#if WHITE_FURNACE_TEST > 0
    #include "../Colour.glsl"
    #define COMPUTE_SHEEN 1
#endif

#if !defined(COMPUTE_SHEEN)
    #define COMPUTE_SHEEN 0
#endif

#if !defined(TILED_RENDERING)
    #define TILED_RENDERING 0
#endif
#if !defined(SHADER_INDEX)
    #define SHADER_INDEX 0
#endif

#if TILED_RENDERING > 0
    #include "../classification/ClassificationBuffer.glsl"
#endif

#include "../geometry/GBuffer.glsl"
#include "../Camera.glsl"
#include "Brdf.glsl"
#include "../Maths.glsl"


layout(binding = 0) uniform sampler2D depthBufferTexture;
layout(binding = 1) uniform sampler2D missingSpecularLutTexture;

#if WHITE_FURNACE_TEST <= 0

layout(binding = 4) uniform samplerCube u_irradiance_texture;
layout(binding = 5) uniform samplerCube u_pre_filter_texture;

uniform float u_luminance_multiplier;

#endif

#if COMPUTE_SHEEN > 0
layout(binding = 6) uniform sampler2D sheenLut;
layout(binding = 7) uniform sampler2D sheenMissing;
#endif

layout(binding = 1, rgba16f) uniform image2D lighting;

// specular missing is split as we don't know f0 until now.
vec3 reconstructSpecularMissing(vec3 f0, float nDotV, float roughness)
{
    const vec3 f0Average = (20.f / 21.f) * f0 + vec3(1.f / 21.f);

    const float avgRspec = directionalAlbedoAverageWhite(vec2(roughness, 0.5f));
    const float oneMinusAvgRspec = 1.f - avgRspec;

    const float thatSummationPartOnTheRight = texture(missingSpecularLutTexture, vec2(nDotV, roughness)).r;

    const vec3 denominator = (vec3(1.f) - f0Average * oneMinusAvgRspec);

    return f0Average / denominator * thatSummationPartOnTheRight;
}

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main()
{
#if TILED_RENDERING > 0
    const uint tileIndex = gl_WorkGroupID.x;
    const uvec2 workGroupId = tileBuffers[tileIndex][SHADER_INDEX];

    const uvec2 pixelCoord = workGroupId * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy;
    const vec2 id = vec2(pixelCoord);
#else
    const vec2 id = gl_GlobalInvocationID.xy;
#endif
    const vec2 uv = (id - vec2(0.5f)) / textureSize(depthBufferTexture, 0);
    const float depth = texture(depthBufferTexture, uv).r;
    const vec3 position = positionFromDepth(uv, depth);

    GBuffer gBuffer = pullFromStorageGBuffer(ivec2(id));

    if (gBufferIsValid(gBuffer) == 0)
        return;

    const vec3 n = gBuffer.normal;
    const vec3 v = normalize(camera.position - position);
    const vec3 r = reflect(-v, n);

    const float vDotN = max(dot(v, n), 0.f);

#if WHITE_FURNACE_TEST > 0
    const vec3 fresnel = vec3(1.f);
#else
    const vec3 fresnel = fresnelSchlick(gBuffer.specular, vDotN);
#endif

    const vec2 lut = texture(directionalAlbedoLut, vec2(vDotN, gBuffer.roughness)).rg;
    const vec3 specular = (fresnel * lut.x + lut.y);
    const vec3 specMissing = reconstructSpecularMissing(fresnel, vDotN, gBuffer.roughness);

    // todo: remove dependancy to Brdf.glsl => uniforms are getting too complicated to track.
    const vec3 diffuse = evaluateDiffuseBrdf(gBuffer, specular + specMissing);

    vec3 sheen = vec3(0.f);
    float sheenScalar = 1.f;
#if COMPUTE_SHEEN > 0
    if (gBufferHasFlag(gBuffer, GBUFFER_FLAG_FUZZ_BIT) == 1)
    {
    #if WHITE_FURNACE_TEST > 0
        sheen = texture(sheenLut, vec2(vDotN, gBuffer.fuzzRoughness)).rrr;
        sheenScalar = texture(sheenMissing, vec2(vDotN, gBuffer.fuzzRoughness)).r;
    #else
        sheen = gBuffer.fuzzColour * texture(sheenLut, vec2(vDotN, gBuffer.fuzzRoughness)).r;
        sheenScalar = texture(sheenMissing, vec2(vDotN, gBuffer.fuzzRoughness)).r;
    #endif
    }
#endif

    // todo: specular + diffuse needs to be scaled back using the min-scale method. Possibly in the G channel as we need V right?

#if WHITE_FURNACE_TEST > 0
    const vec3 colour = linearToSRgb(sheen + sheenScalar * (specular + specMissing + diffuse) - vec3(0.5f));
    imageStore(lighting, ivec2(id), vec4(colour, 1.f));
#else

    const float maxReflectionLod = 4.f;
    const vec3 preFilterColour = textureLod(u_pre_filter_texture, r, gBuffer.roughness * maxReflectionLod).rgb;
    const vec3 irradiance = texture(u_irradiance_texture, n).rgb;

    const vec3 colour = imageLoad(lighting, ivec2(id)).rgb;
    const vec3 outColour = colour + camera.exposure * (sheenScalar * (specular + specMissing) * preFilterColour + (sheenScalar * diffuse + sheen) * irradiance) * u_luminance_multiplier;
    imageStore(lighting, ivec2(id), vec4(outColour, 1.f));
#endif
}
