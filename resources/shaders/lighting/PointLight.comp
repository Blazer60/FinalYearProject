#version 460

#include "../interfaces/PointLightBlock.h"
#include "../interfaces/CameraBlock.h"
#include "../classification/ClassificationBuffer.glsl"
#include "Brdf.glsl"
#include "../geometry/GBuffer.glsl"
#include "../Camera.glsl"

layout(binding = 0) uniform sampler2D depthBufferTexture;
layout(binding = 1) uniform samplerCube u_shadow_map_texture;

layout(binding = 1, rgba16f) uniform image2D lighting;

float sample_shadow_map(vec3 direction, float pixel_depth, float bias)
{
    const float shadow_depth = texture(u_shadow_map_texture, -direction).x * cLight.zFar;
    return pixel_depth - bias > shadow_depth ? 1.f : 0.f;
}

float calculate_shadow_map(vec3 light_direction)
{
    const vec3 samples_offsets[20] = vec3[20](
        vec3( 1,  1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1,  1,  1),
        vec3( 1,  1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1,  1, -1),
        vec3( 1,  1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1,  1,  0),
        vec3( 1,  0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1,  0, -1),
        vec3( 0,  1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0,  1, -1)
    );
    const float disk_radius = cLight.softnessRadius;

    float shadow = 0.f;
    for (int i = 0; i < 20; i++)
    {
        const vec3 direction = light_direction + samples_offsets[i] * disk_radius;
        const float pixel_depth = length(direction);
        const float bias = mix(cLight.bias.x, cLight.bias.y, clamp(pixel_depth / cLight.zFar, 0.f, 1.f));
        shadow += sample_shadow_map(direction, pixel_depth, bias);
    }

    return shadow / 20.f;
}

float smoothDistanceAttenuation(float distance2, float invSqrAttRadius)
{
    const float factor = distance2 * invSqrAttRadius;
    const float smoothFactor = clamp(1.f - factor * factor, 0.f, 1.f);
    return smoothFactor * smoothFactor;
}

float getDistanceAttenuation(vec3 lightVector, float invSqrAttRadius)
{
    const float distance2 = dot(lightVector, lightVector);
    float attenuation = 1.f / (max(distance2, 0.01f * 0.01f));  // Point lights are considered to have a radius of 1cm.
    attenuation *= smoothDistanceAttenuation(distance2, invSqrAttRadius);

    return attenuation;
}

layout(local_size_x = TILE_THREAD_GROUP_SIZE, local_size_y = TILE_THREAD_GROUP_SIZE, local_size_z = 1) in;
void main()
{
    const uint tileIndex = gl_WorkGroupID.x;
    const uint tileBufferResult = tileBuffers[tileIndex][SHADER_INDEX];
    const uvec2 workGroupId = uvec2(tileBufferResult & 0x0000FFFFu, (tileBufferResult & 0xFFFF0000u) >> 16);

    const uvec2 pixelCoord = workGroupId * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy;
    const vec2 id = vec2(pixelCoord);

    const vec2 uv = (id - vec2(0.5f)) / textureSize(depthBufferTexture, 0);

    const float depth = texture(depthBufferTexture, uv).r;
    const vec3 position = positionFromDepth(uv, depth);

    GBuffer gBuffer = pullFromStorageGBuffer(ivec2(id));

    const vec3 light_direction = cLight.position - position;
    const vec3 l = normalize(light_direction);
    float attenuation = 1.f;
    attenuation *= getDistanceAttenuation(light_direction, cLight.invSqrRadius);
    const float shadow_intensity = calculate_shadow_map(light_direction);
    const vec3 radiance = attenuation * cLight.intensity * (1.f - shadow_intensity);

    vec3 colour = imageLoad(lighting, ivec2(id)).rgb;
    colour += camera.exposure * evaluateBxDF(gBuffer, position, l, radiance);
    imageStore(lighting, ivec2(id), vec4(colour, 1.f));
}
