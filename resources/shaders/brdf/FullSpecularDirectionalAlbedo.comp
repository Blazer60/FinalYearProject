#version 460 core

#include "../Maths.glsl"
#include "Hammersley.glsl"
#include "Ggx.glsl"

layout(binding = 0) uniform sampler2D ggxDirectionalAlbedoLut;
layout(binding = 1) uniform sampler2D specularMissingDirectionalAlbedoLut;
layout(binding = 2) uniform sampler2D ggxDirectionalAlbedoAverageLut;
layout(binding = 0, r16f) writeonly uniform image3D fullSpecularLut;

float directionalAlbedoWhite(vec2 uv)
{
    const vec2 result = texture(ggxDirectionalAlbedoLut, uv).rg;
    return result.x + result.y;
}

float directionalAlbedoAverage(vec2 uv, float f0)
{
    vec2 result = texture(ggxDirectionalAlbedoAverageLut, uv).rg;
    return f0 * result.x + result.y;
}

float reconstructSpecularMissing(float f0, float nDotV, float nDotL, float roughness)
{
    const float f0Average = (20.f / 21.f) * f0 + (1.f / 21.f);

    const float avgRspec = directionalAlbedoAverage(vec2(roughness, 0.5f), 1.f);
    const float oneMinusAvgRspec = 1.f - avgRspec;

    const float denominator = 1.f - f0Average * oneMinusAvgRspec;

    const float f0Part = f0Average * avgRspec / denominator;

    const float oneMinusRsf1L = 1.f - directionalAlbedoWhite(vec2(nDotL, roughness));
    const float oneMinusRsf1V = 1.f - directionalAlbedoWhite(vec2(nDotV, roughness));

    const float rsf1Part = oneMinusRsf1L * oneMinusRsf1V / (PI * oneMinusAvgRspec + 0.001f);

    return f0Part * rsf1Part;
}

float evaluateSpecularPart(float f0, float nDotV, float nDotL, float nDotH, float alpha)
{
    const float fresnel = fresnelSchlick(f0, nDotL);
    const float geometry = ggxGeometry2Unreal(nDotV, nDotL, alpha);
    const float distribution = ggxDistribution(nDotH, alpha * alpha);

    const float denominator = 4.f * nDotL * nDotV + 0.001f;

    return fresnel * geometry * distribution / denominator;
}

float integrateFullSpecular(float nDotV, float roughness, float f0)
{
    const vec3 v = vec3(sqrt(1.f - nDotV * nDotV), 0.f, nDotV);
    const vec3 n = vec3(0.f, 0.f, 1.f);

    float accumulation = 0.f;

    const float alpha = roughness * roughness;
    const float alpha2 = alpha * alpha;

    const uint sampleCount = 1024u;
    for (uint i = 0u; i < sampleCount; ++i)
    {
        const vec2 rand = hammersley(i, sampleCount);
        const vec3 h = ggxImportanceSample(rand, n, alpha2);
        const vec3 l = normalize(2.f * dot(v, h) * h - v);

        const float nDotL = saturate(dot(n, l));
        const float nDotH = saturate(dot(n, h));
        const float vDotH = saturate(dot(v, h));

        if (nDotL > 0.f)
        {
            const float f0Part = evaluateSpecularPart(f0, nDotV, nDotL, nDotH, alpha) + reconstructSpecularMissing(f0, nDotV, nDotL, roughness);
            const float fourDPart = 4.f * vDotH * nDotL / (ggxDistribution(nDotH, alpha2) * nDotH);
            accumulation += f0Part * fourDPart;
        }
    }

    return accumulation / float(sampleCount);
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
void main()
{
    const vec3 id = gl_GlobalInvocationID;
    const vec3 dispatchSize = gl_NumWorkGroups * gl_WorkGroupSize;
    const vec3 uv = vec3(1.f) - ((id + vec3(0.5f)) / dispatchSize);

    const float result = integrateFullSpecular(uv.x, uv.y, uv.z);

    imageStore(fullSpecularLut, ivec3(dispatchSize) - ivec3(1) - ivec3(id), vec4(result.x, 0.f, 0.f, 0.f));
}