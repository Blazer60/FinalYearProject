#version 460 core

#include "Hammersley.glsl"
#include "../Maths.glsl"

layout(binding = 0) uniform sampler3D fullSpecularDirectionalAlbedoLut;
layout(binding = 1) uniform sampler2D fullSpecularDirectionalAlbedoAverageLut;
layout(binding = 0, r16f) writeonly uniform image3D diffuseDirectionalAlbedoLut;

float integrateDiffuseDirectionalAlbedo(float nDotV, float roughness, float f0)
{
    const vec3 v = vec3(sqrt(1.f - nDotV * nDotV), 0.f, nDotV);
    const vec3 n = vec3(0.f, 0.f, 1.f);

    float accumulation = 0.f;

    const uint sampleCount = 1024u;
    for (uint i = 0u; i < sampleCount; ++i)
    {
        const vec2 rand = hammersley(i, sampleCount);
        const vec3 l = cosImportanceSample(rand, n);
        const vec3 v = normalize(l + v);

        const float nDotL = saturate(dot(n, l));

        const float oneMinusRspecL = 1.f - texture(fullSpecularDirectionalAlbedoLut, vec3(nDotL, roughness, f0)).r;
        const float oneMinusRspecV = 1.f - texture(fullSpecularDirectionalAlbedoLut, vec3(nDotV, roughness, f0)).r;
        const float oneMinusRspecAverage = 1.f - texture(fullSpecularDirectionalAlbedoAverageLut, vec2(roughness, f0)).r;

        accumulation += oneMinusRspecL * oneMinusRspecV / oneMinusRspecAverage;
    }

    return accumulation / float(sampleCount);
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
void main()
{
    const vec3 id = gl_GlobalInvocationID;
    const vec3 dispatchSize = gl_NumWorkGroups * gl_WorkGroupSize;
    const vec3 uv = vec3(1.f) - ((id + vec3(0.5f)) / dispatchSize);

    const float result = integrateDiffuseDirectionalAlbedo(uv.x, uv.y, uv.z);

    imageStore(diffuseDirectionalAlbedoLut, ivec3(dispatchSize) - ivec3(1) - ivec3(id), vec4(result.x, 0.f, 0.f, 0.f));
}
