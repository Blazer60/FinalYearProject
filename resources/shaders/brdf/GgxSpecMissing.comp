#version 460 core

#include "Hammersley.glsl"
#include "Ggx.glsl"
#include "../Maths.glsl"

layout(binding = 0) uniform sampler2D directionalAlbedoWhite;
layout(binding = 1) uniform sampler2D directionalAlbedoAverageWhite;
layout(binding = 0, r16f) writeonly uniform image2D specMissing;

float integrateGgxSpecularMissing(float nDotV, float roughness)
{
    const vec3 v = vec3(sqrt(1.f - nDotV * nDotV), 0.f, nDotV);
    const vec3 n = vec3(0.f, 0.f, 1.f);

    const float rspecV = 1.f - texture(directionalAlbedoWhite, vec2(nDotV, roughness)).r;
    const float averagerspec = 1.f - texture(directionalAlbedoAverageWhite, vec2(roughness, 0.5f)).r;

    float accumulation = 0.f;

    const float alpha2 = roughness * roughness * roughness * roughness;

    const uint sampleCount = 1024u;
    for (uint i = 0u; i < sampleCount; ++i)
    {
        const vec2 rand = hammersley(i, sampleCount);
        // Is this actually ggx importance sampled. Or should it be cosine?
        const vec3 l = cosImportanceSample(rand, n);
        const vec3 h = normalize(l + v);
//        const vec3 h = ggxImportanceSample(rand, n, alpha2);
//        const vec3 l = normalize(2.f * dot(v, h) * h - v);

        const float nDotL = saturate(dot(n, l));
        const float nDotH = saturate(dot(n, h));

        if (nDotL > 0.f)
        {
//            const float dPart = 4.f * nDotV * nDotL / (ggxDistribution(nDotH, alpha2) * nDotH);
            const float rspecL = 1.f - texture(directionalAlbedoWhite, vec2(nDotL, roughness)).r;
            accumulation += rspecV * rspecL / (averagerspec + 0.001f);
        }
    }

    return accumulation / float(sampleCount);
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
    const vec3 id = gl_GlobalInvocationID;
    const vec3 dispatchSize = gl_NumWorkGroups * gl_WorkGroupSize;
    const vec2 uv = vec2(1.f) - ((id.xy + vec2(0.5f)) / dispatchSize.xy);

    const float result = integrateGgxSpecularMissing(uv.x, uv.y);

    imageStore(specMissing, ivec2(dispatchSize) - ivec2(1) - ivec2(id.xy), vec4(result.x, 0.f, 0.f, 0.f));
}
