#version 460 core

#include "Ggx.glsl"
#include "Hammersley.glsl"

#if !defined(WHITE_DIRECTIONAL_ALBEDO)
    #define WHITE_DIRECTIONAL_ALBEDO 0
#endif

layout(binding = 0) writeonly uniform image2D lut;

vec2 integrateGgxDirectionalAlbedo(float nDotV, float roughness)
{
    const vec3 V = vec3(sqrt(1.f - nDotV * nDotV), 0.f, nDotV);

    float A = 0.f;
    float B = 0.f;

    vec3 N = vec3(0.f, 0.f, 1.f);
    const float alpha = roughness * roughness;
    const float alpha2 = alpha * alpha;

    const uint sampleCount = 1024u;
    for (uint i = 0u; i < sampleCount; ++i)
    {
        const vec2 xI = hammersley(i, sampleCount);
        const vec3 H = ggxImportanceSample(xI, N, alpha2);
        const vec3 L = normalize(2.f * dot(V, H) * H - V);

        const float nDotL = saturate(dot(N, L));
        const float nDotH = saturate(dot(N, H));
        const float vDotH = saturate(dot(V, H));

        if (nDotL > 0.f)
        {
            const float G = ggxGeometry2Unreal(nDotV, nDotL, alpha);
            const float gVis = (G * vDotH) / (nDotH * nDotV);

#if WHITE_DIRECTIONAL_ALBEDO > 0
            A += gVis;
#else
            const float fC = pow(1.f - vDotH, 5.f);
            A += (1.f - fC) * gVis;
            B += fC * gVis;
#endif
        }
    }

    A /= float(sampleCount);
    B /= float(sampleCount);

    return vec2(A, B);
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
    const vec3 id = gl_GlobalInvocationID;
    const vec3 dispatchSize = gl_NumWorkGroups * gl_WorkGroupSize;
    const vec2 uv = vec2(1.f) - ((id.xy + vec2(0.5f)) / dispatchSize.xy);

    const vec2 result = integrateGgxDirectionalAlbedo(uv.x, uv.y);

    imageStore(lut, ivec2(dispatchSize) - ivec2(1) - ivec2(id.xy), vec4(result.xy, 0.f, 0.f));
}
