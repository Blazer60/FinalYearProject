#version 460 core

layout(binding = 0, rgba32ui) uniform uimage2DArray storageGBuffer;
layout(binding = 1, rgba32f) uniform image2D testScreen;

#define BYTES 8
#define UINT_SIZE 4
#define DATA_STREAM_SIZE 8
#define GBUFFER_LAYER_COUNT 3

struct Stream
{
    // Do not touch data. Use the helper functions to get information.
    uint data[DATA_STREAM_SIZE];
    int byteOffset;  // Should start at 1.
};

void streamRecordUintCount(in out Stream stream)
{
    const uint uintCount = uint(ceil(stream.byteOffset / UINT_SIZE));
    stream.data[0] = bitfieldInsert(stream.data[0], uintCount, 0 * BYTES, 1 * BYTES);
}

void streamInsertBytes(in out Stream stream, uint bytes, int byteCount)
{
    const int index = int(floor(stream.byteOffset / UINT_SIZE));
    const int localOffset = stream.byteOffset % UINT_SIZE;
    const int localSpaceRemaining = UINT_SIZE - localOffset;
    if (localSpaceRemaining > byteCount)
    {
        // direction insertion, we do not have to split our packedVector.
        stream.data[index] = bitfieldInsert(stream.data[index], bytes, localOffset * BYTES, byteCount * BYTES);
    }
    else
    {
        // need to split our packed vector.
        const int leftSize = localSpaceRemaining;
        const int rightSize = byteCount - localSpaceRemaining;

        const uint leftPart  = bitfieldExtract(bytes, 0 * BYTES,        leftSize * BYTES);
        const uint rightPart = bitfieldExtract(bytes, leftSize * BYTES, rightSize * BYTES);

        stream.data[index]     = bitfieldInsert(stream.data[index],      leftPart,  localOffset * BYTES, leftSize * BYTES);
        stream.data[index + 1] = bitfieldInsert(stream.data[index + 1],  rightPart, 0 * BYTES,           rightSize * BYTES);
    }

    stream.byteOffset += byteCount;
}

void streamPackUnorm4x8(in out Stream stream, vec4 vector, int elementCount)
{
    uint packedVector = packUnorm4x8(vector);

    streamInsertBytes(stream, packedVector, elementCount);
}

uint streamExtractBytes(in out Stream stream, int byteCount)
{
    const int index = int(floor(stream.byteOffset / UINT_SIZE));
    const int localOffset = stream.byteOffset % UINT_SIZE;
    const int localSpaceRemaining = UINT_SIZE - localOffset;

    stream.byteOffset += byteCount;

    if (localSpaceRemaining > byteCount)
    {
        // direct extraction.
        return bitfieldExtract(stream.data[index], localOffset * BYTES, byteCount * BYTES);
    }
    else
    {
        const int leftSize = localSpaceRemaining;
        const int rightSize = byteCount - localSpaceRemaining;

        const uint leftPart   = bitfieldExtract(stream.data[index], localOffset * BYTES, leftSize * BYTES);
        const uint rightPart  = bitfieldExtract(stream.data[index + 1], 0 * BYTES, rightSize * BYTES);

        uint result = bitfieldInsert(0, leftPart, 0 * BYTES, leftSize * BYTES);
        result      = bitfieldInsert(result, rightPart, leftSize * BYTES, rightSize * BYTES);
        return result;
    }
}

vec4 streamUnpackUnorm4x8(in out Stream stream, int elementCount)
{
    return unpackUnorm4x8(streamExtractBytes(stream, elementCount));
}

void streamPushToStorageGBuffer(Stream stream, ivec2 coord)
{
    streamRecordUintCount(stream);
    const int uintCount = int(ceil(stream.byteOffset / UINT_SIZE));

    for (int index = 0; index < uintCount; index += 4)
    {
        imageStore(storageGBuffer, ivec3(coord, int(floor(index / 4))), uvec4(stream.data[index], stream.data[index + 1], stream.data[index + 2], stream.data[index + 3]));
    }
}

Stream streamPullFromStorageGBuffer(ivec2 coord)
{
    Stream stream;
    stream.byteOffset = 0;

    const uvec4 slice = imageLoad(storageGBuffer, ivec3(coord, 0));
    stream.data[0] = slice.x;
    stream.data[1] = slice.y;
    stream.data[2] = slice.z;
    stream.data[3] = slice.w;
    const uint uintCount = streamExtractBytes(stream, 1);

    int i = 1;
    for (int index = 4; index < uintCount * 4; index += 4)
    {
        const uvec4 slice = imageLoad(storageGBuffer, ivec3(coord, i++));
        stream.data[index + 0] = slice.x;
        stream.data[index + 1] = slice.y;
        stream.data[index + 2] = slice.z;
        stream.data[index + 3] = slice.w;
    }

    return stream;
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
    Stream stream;
    stream.byteOffset = 1;

    const vec4 junk0 = vec4(1.f);
    const vec4 junk1 = vec4(0.5f);
    const vec4 junk2 = vec4(0.5f);
    const vec4 junk3 = vec4(1.0f);

    const vec4 diffuse = vec4(0.9f, 0.5f, 0.3f, 0.f);
    const vec4 specular = vec4(1.f, 1.f, 1.f, 0.f);

    streamPackUnorm4x8(stream, junk0, 4);
    streamPackUnorm4x8(stream, junk1, 4);
    streamPackUnorm4x8(stream, junk2, 4);
    streamPackUnorm4x8(stream, junk3, 4);
    streamPackUnorm4x8(stream, specular, 3);
    streamPackUnorm4x8(stream, diffuse, 3);

    streamPushToStorageGBuffer(stream, ivec2(gl_GlobalInvocationID.xy));
    groupMemoryBarrier();
    // Unpacking
    stream = streamPullFromStorageGBuffer(ivec2(gl_GlobalInvocationID.xy));

    streamUnpackUnorm4x8(stream, 4);
    streamUnpackUnorm4x8(stream, 4);
    streamUnpackUnorm4x8(stream, 4);
    streamUnpackUnorm4x8(stream, 4);
    const vec3 outSpecular = streamUnpackUnorm4x8(stream, 3).xyz;
    const vec3 outDiffuse  = streamUnpackUnorm4x8(stream, 3).xyz;

    imageStore(testScreen, ivec2(gl_GlobalInvocationID.xy), vec4(outDiffuse, 0.f));
}
