#version 460 core

layout(binding = 0, rgba32f) uniform image2D screen;

#define BYTES 8
#define UINT_SIZE 4

struct Stream
{
    uint data[8];
    int byteOffset;
};

void streamInsertBytes(in out Stream stream, uint bytes, int byteCount)
{
    const int index = int(floor(stream.byteOffset / UINT_SIZE));
    const int localOffset = stream.byteOffset % UINT_SIZE;
    const int localSpaceRemaining = UINT_SIZE - localOffset;
    if (localSpaceRemaining > byteCount)
    {
        // direction insertion, we do not have to split our packedVector.
        stream.data[index] = bitfieldInsert(stream.data[index], bytes, localOffset * BYTES, byteCount * BYTES);
    }
    else
    {
        // need to split our packed vector.
        const int leftSize = localSpaceRemaining;
        const int rightSize = byteCount - localSpaceRemaining;

        const uint leftPart  = bitfieldExtract(bytes, 0 * BYTES,        leftSize * BYTES);
        const uint rightPart = bitfieldExtract(bytes, leftSize * BYTES, rightSize * BYTES);

        stream.data[index]     = bitfieldInsert(stream.data[index],      leftPart,  localOffset * BYTES, leftSize * BYTES);
        stream.data[index + 1] = bitfieldInsert(stream.data[index + 1],  rightPart, 0 * BYTES,           rightSize * BYTES);
    }

    stream.byteOffset += byteCount;
}

void streamPackUnorm(in out Stream stream, vec4 vector, int elementCount)
{
    uint packedVector = packUnorm4x8(vector);

    streamInsertBytes(stream, packedVector, elementCount);
}

uint streamExtractBytes(in out Stream stream, int byteCount)
{
    const int index = int(floor(stream.byteOffset / UINT_SIZE));
    const int localOffset = stream.byteOffset % UINT_SIZE;
    const int localSpaceRemaining = UINT_SIZE - localOffset;

    stream.byteOffset += byteCount;

    if (localSpaceRemaining > byteCount)
    {
        // direct extraction.
        return bitfieldExtract(stream.data[index], localOffset * BYTES, byteCount * BYTES);
    }
    else
    {
        const int leftSize = localSpaceRemaining;
        const int rightSize = byteCount - localSpaceRemaining;

        const uint leftPart   = bitfieldExtract(stream.data[index], localOffset * BYTES, leftSize * BYTES);
        const uint rightPart  = bitfieldExtract(stream.data[index + 1], 0 * BYTES, rightSize * BYTES);

        uint result = bitfieldInsert(0, leftPart, 0 * BYTES, leftSize * BYTES);
        result      = bitfieldInsert(result, rightPart, leftSize * BYTES, rightSize * BYTES);
        return result;
    }
}

vec4 streamUnpackUnorm(in out Stream stream, int elementCount)
{
    return unpackUnorm4x8(streamExtractBytes(stream, elementCount));
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
    Stream stream;
    stream.byteOffset = 0;

    const vec4 diffuse = vec4(0.9f, 0.5f, 0.3f, 0.f);
    const vec4 specular = vec4(1.f, 1.f, 1.f, 0.f);

    streamPackUnorm(stream, specular, 3);
    streamPackUnorm(stream, diffuse, 3);

    // Unpacking - reverse of above.
    stream.byteOffset = 0;
    const vec3 outSpecular = streamUnpackUnorm(stream, 3).xyz;
    const vec3 outDiffuse  = streamUnpackUnorm(stream, 3).xyz;

    // test this with easy uint values to float to make sure my understanding is correct.
    imageStore(screen, ivec2(gl_GlobalInvocationID.xy), vec4(outDiffuse, 0.f));
}
